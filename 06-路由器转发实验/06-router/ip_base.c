#include "ip.h"
#include "icmp.h"
#include "arpcache.h"
#include "rtable.h"
#include "arp.h"

// #include "log.h"

#include <stdio.h>
#include <stdlib.h>

// initialize ip header 
void ip_init_hdr(struct iphdr *ip, u32 saddr, u32 daddr, u16 len, u8 proto)
{
	ip->version = 4;
	ip->ihl = 5;
	ip->tos = 0;
	ip->tot_len = htons(len);
	ip->id = rand();
	ip->frag_off = htons(IP_DF);
	ip->ttl = DEFAULT_TTL;
	ip->protocol = proto;
	ip->saddr = htonl(saddr);
	ip->daddr = htonl(daddr);
	ip->checksum = ip_checksum(ip);
}

// lookup in the routing table, to find the entry with the same and longest prefix.
// the input address is in host byte order
rt_entry_t *longest_prefix_match(u32 dst)
{
	fprintf(stderr, "TODO: longest prefix match for the packet.\n");
	rt_entry_t *req_entry = NULL, *req_q;
	rt_entry_t *temp = NULL;
	list_for_each_entry_safe(req_entry, req_q,&(rtable),list){
		if((req_entry -> dest & req_entry -> mask) == (dst & req_entry -> mask)){
			if(temp == NULL){
				temp = req_entry;
			}
			else if((req_entry -> mask > temp -> mask)){
				temp = req_entry;
			}
		}
		fprintf(stderr, "lpm %x %x %x %p\n", req_entry -> dest, dst, req_entry -> mask, temp);
	}
	return temp;
}

// send IP packet
//
// Different from forwarding packet, ip_send_packet sends packet generated by
// router itself. This function is used to send ICMP packets.
void ip_send_packet(char *packet, int len)
{
	fprintf(stderr, "TODO: send ip packet.\n");

	struct ether_header *ip_ether_header;
	ip_ether_header = (struct ether_header *)packet;
	struct iphdr *ip_iphdr;
	ip_iphdr = (struct iphdr *)(packet + sizeof(struct ether_header));

	u32 ip2;
	ip2 = ntohl(ip_iphdr -> daddr);

	rt_entry_t *rtable2 = longest_prefix_match(ip2);
	ip_iphdr -> ttl--;
	if(ip_iphdr -> ttl == 0){
		icmp_send_packet(packet,len,ICMP_TIME_EXCEEDED,ICMP_EXC_TTL);
	}
	else{
		ip_iphdr -> checksum = ip_checksum(ip_iphdr);
		if(rtable2 == NULL){
			fprintf(stderr, "rtable %x\n", ip2);
			icmp_send_packet(packet,len,ICMP_DEST_UNREACH, ICMP_NET_UNREACH);
			// void icmp_send_packet(const char *in_pkt, int len, u8 type, u8 code);
		}
		else{
			iface_info_t *port2 = rtable2 -> iface;
			for(int i = 0; i < ETH_ALEN; i++){
				ip_ether_header-> ether_shost[i] = port2 -> mac[i];
			}
			if(rtable2 -> gw != 0){
				if( arpcache_lookup(rtable2 -> gw, ip_ether_header -> ether_dhost) ){
					iface_send_packet(port2, packet, len);
				}
				else{
					arpcache_append_packet(port2,rtable2 -> gw,packet,len);
				}
			}
			else{
				if( arpcache_lookup(ip2, ip_ether_header -> ether_dhost) ){
					iface_send_packet(port2, packet, len);
				}
				else{
					arpcache_append_packet(port2,ip2,packet,len);
				}
			}
			//arpcache_append_packet(iface_info_t *iface, u32 ip4, char *packet, int len)
		}
	}
}
